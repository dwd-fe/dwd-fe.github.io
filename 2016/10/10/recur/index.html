<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 点我达前端博客</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="/css/Dwd-Fe.css"><link rel="icon" href="/img/favicon.png"></head><body><div class="wrapper"><header id="menu-outer"><a href="/"><div class="logo"><img src="http://7xtb3a.com2.z0.glb.clouddn.com/icon@2x.png"></div></a><nav id="menu-inner"><a href="/">首页</a><a href="/archives">分类</a><a href="/about">关于我们</a><a href="https://github.com/dwd-fe">Github</a></nav></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="post-space"><div class="post-title"><h1>Javascript中匿名函数的递归调用</h1><h2>by 愚安 on 2016-10-10</h2><h2><span>分类 </span><a class="tags-link" href="/tags/javascript/">javascript</a></h2></div></div><img src="http://cdn.codedocker.com/2016-09-19-14742702215275.jpg" class="post-back"></div><div class="post-content"><p>不管是什么编程语言，相信稍微写过几行代码的同学，对递归都不会陌生。<br>以一个简单的阶乘计算为例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> n * factorial(n<span class="number">-1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看出，递归就是在函数内部调用对自身的调用。<br>那么问题来了，我们知道在Javascript中，有一类函数叫做匿名函数，没有名称，怎么调用呢？当然你可以说，可以把匿名函数赋值给一个常量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> factorial = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</div><div class="line">	 <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> n * factorial(n<span class="number">-1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这当然是可以的。但是对于一些像，函数编写时并不知道自己将要赋值给一个明确的变量的情况时，就会遇到麻烦了。如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">f</span>)</span>&#123;</div><div class="line">	f(<span class="number">10</span>);</div><div class="line">&#125;)(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</div><div class="line">	 <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> n * factorial(n<span class="number">-1</span>);<span class="comment">//太依赖于上下文变量名</span></div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line"><span class="comment">//Uncaught ReferenceError: factorial is not defined(…)</span></div></pre></td></tr></table></figure>
<p>那么存不存在一种完全不需要这种给予准确函数名(函数引用变量名)的方式呢？</p>
<h2 id="arguments-callee"><a href="#arguments-callee" class="headerlink" title="arguments.callee"></a>arguments.callee</h2><p>我们知道在任何一个<code>function</code>内部，都可以访问到一个叫做<code>arguments</code>的变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.dir(<span class="built_in">arguments</span>)&#125;)(<span class="number">1</span>,<span class="number">2</span>)</div></pre></td></tr></table></figure>
<p><img src="http://cdn.codedocker.com/2016-09-19-屏幕快照 2016-09-18 下午10.53.58.png" alt="屏幕快照 2016-09-18 下午10.53.58"><br>打印出这个<code>arguments</code>变量的细节，可以看出他是<code>Arguments</code>的一个实例，而且从数据结构上来讲，他是一个类数组。他除了类数组的元素成员和<code>length</code>属性外，还有一个<code>callee</code>方法。<br>那么这个<code>callee</code>方法是做什么的呢？我们来看下<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments/callee" target="_blank" rel="external">MDN</a></p>
<blockquote>
<p><code>callee</code> 是 <code>arguments</code> 对象的属性。在该函数的函数体内，它可以指向当前正在执行的函数。当函数是匿名函数时，这是很有用的， 比如没有名字的函数表达式 (也被叫做”匿名函数”)。</p>
</blockquote>
<p>哈哈，很明显这就是我们想要的。接下来就是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">f</span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(f(<span class="number">10</span>));</div><div class="line">&#125;)(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</div><div class="line">	 <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> n * <span class="built_in">arguments</span>.callee(n<span class="number">-1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line"><span class="comment">//output: 3628800</span></div></pre></td></tr></table></figure>
<p>但是还有一个问题，MDN的文档里明确指出</p>
<blockquote>
<p><code>警告</code>：在 ECMAScript 第五版 (ES5) 的 严格模式 中禁止使用 arguments.callee()。</p>
</blockquote>
<p>哎呀，原来在ES5的<code>use strict;</code>中不给用啊，那么在ES6中，我们换个ES6的<code>arrow function</code>写写看：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="function">(<span class="params">f</span>) =&gt;</span> <span class="built_in">console</span>.log(f(<span class="number">10</span>)))(</div><div class="line">	<span class="function">(<span class="params">n</span>) =&gt;</span> n &lt;= <span class="number">1</span>? <span class="number">1</span>: <span class="built_in">arguments</span>.callee(n<span class="number">-1</span>))</div><div class="line"><span class="comment">//Uncaught ReferenceError: arguments is not defined(…)</span></div></pre></td></tr></table></figure>
<p>有一定ES6基础的同学，估计老早就想说了，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="external">箭头函数</a>就是个简写形式的函数表达式，并且它拥有词法作用域的<code>this</code>值（即不会新产生自己作用域下的<code>this</code>, <code>arguments</code>, <code>super</code> 和 <code>new.target</code> 等对象），且都是匿名的。</p>
<p>那怎么办呢？嘿嘿，我们需要借助一点FP的思想了。</p>
<h3 id="Y组合子"><a href="#Y组合子" class="headerlink" title="Y组合子"></a>Y组合子</h3><p>关于<code>Y Combinator</code>的文章可谓数不胜数，这个由师从希尔伯特的著名逻辑学家<a href="https://en.wikipedia.org/wiki/Haskell_Curry" target="_blank" rel="external">Haskell B.Curry</a>（Haskell语言就是以他命名的，而函数式编程语言里面的Curry手法也是以他命名）“发明”出来的组合算子（Haskell是研究<a href="https://en.wikipedia.org/wiki/Combinatory_logic" target="_blank" rel="external">组合逻辑(combinatory logic)</a>的）仿佛有种神奇的魔力，它能够算出给定lambda表达式（函数）的<a href="https://en.wikipedia.org/wiki/Fixed_point" target="_blank" rel="external">不动点</a>。从而使得递归成为可能。</p>
<p>这里需要告知一个概念<code>不动点组合子</code>：</p>
<blockquote>
<p>不动点组合子（英语：Fixed-point combinator，或不动点算子）是计算其他函数的一个不动点的高阶函数。</p>
<p>函数f的不动点是一个值x使得<code>f(x) = x</code>。例如，0和1是函数 f(x) = x^2 的不动点，因为 0^2 = 0而 1^2 = 1。鉴于一阶函数（在简单值比如整数上的函数）的不动点是个一阶值，高阶函数f的不动点是另一个函数g使得<code>f(g) = g</code>。那么，不动点算子是任何函数fix使得对于任何函数f都有</p>
<p><code>f(fix(f)) = fix(f)</code>.<br>不动点组合子允许定义匿名的递归函数。它们可以用非递归的lambda抽象来定义.</p>
</blockquote>
<p>在无类型lambda演算中众所周知的（可能是最简单的）不动点组合子叫做Y组合子。</p>
<p>接下来，我们通过一定的演算推到下这个Y组合子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 首先我们定义这样一个可以用作求阶乘的递归函数</span></div><div class="line"><span class="keyword">const</span> fact = <span class="function">(<span class="params">n</span>) =&gt;</span> n&lt;=<span class="number">1</span>?<span class="number">1</span>:n*fact(n<span class="number">-1</span>)</div><div class="line"><span class="built_in">console</span>.log(fact(<span class="number">5</span>)) <span class="comment">//120</span></div><div class="line"></div><div class="line"><span class="comment">// 既然不让这个函数有名字，我们就先给这个递归方法一个叫做self的代号</span></div><div class="line"><span class="comment">// 首先是一个接受这个递归函数作为参数的一个高阶函数</span></div><div class="line"><span class="keyword">const</span> fact_gen = <span class="function">(<span class="params">self</span>) =&gt;</span> (n) =&gt; n&lt;=<span class="number">1</span>?<span class="number">1</span>:n*self(n<span class="number">-1</span>)</div><div class="line"><span class="built_in">console</span>.log(fact_gen(fact)(<span class="number">5</span>)) <span class="comment">//120</span></div><div class="line"></div><div class="line"><span class="comment">// 我们是将递归方法和参数n，都传入递归方法，得到这样一个函数</span></div><div class="line"><span class="keyword">const</span> fact1 = <span class="function">(<span class="params">self, n</span>) =&gt;</span> n&lt;=<span class="number">1</span>?<span class="number">1</span>:n*self(self, n<span class="number">-1</span>)</div><div class="line"><span class="built_in">console</span>.log(fact1(fact1, <span class="number">5</span>)) <span class="comment">//120</span></div><div class="line"></div><div class="line"><span class="comment">// 我们将fact1 柯理化，得到fact2</span></div><div class="line"><span class="keyword">const</span> fact2 = <span class="function">(<span class="params">self</span>) =&gt;</span> (n) =&gt; n&lt;=<span class="number">1</span>?<span class="number">1</span>:n*self(self)(n<span class="number">-1</span>)</div><div class="line"><span class="built_in">console</span>.log(fact2(fact2)(<span class="number">5</span>)) <span class="comment">//120</span></div><div class="line"></div><div class="line"><span class="comment">// 惊喜的事发生了，如果我们将self(self)看做一个整体</span></div><div class="line"><span class="comment">// 作为参数传入一个新的函数: (g)=&gt; n&lt;= 1? 1: n*g(n-1)</span></div><div class="line"><span class="keyword">const</span> fact3 = <span class="function">(<span class="params">self</span>) =&gt;</span> (n) =&gt; <span class="function">(<span class="params">(g</span>)=&gt;</span>n &lt;= <span class="number">1</span>?<span class="number">1</span>:n*g(n<span class="number">-1</span>))(self(self))</div><div class="line"><span class="built_in">console</span>.log(fact3(fact3)(<span class="number">5</span>)) <span class="comment">//120</span></div><div class="line"></div><div class="line"><span class="comment">// fact3 还有一个问题是这个新抽离出来的函数，是上下文有关的</span></div><div class="line"><span class="comment">// 他依赖于上文的n, 所以我们将n作为新的参数</span></div><div class="line"><span class="comment">// 重新构造出这么一个函数: (g) =&gt; (m) =&gt; m&lt;=1?1:m*g(m-1)</span></div><div class="line"><span class="keyword">const</span> fact4 = <span class="function">(<span class="params">self</span>) =&gt;</span> (n) =&gt; <span class="function">(<span class="params">(g</span>) =&gt;</span> (m) =&gt; m&lt;=<span class="number">1</span>?<span class="number">1</span>:m*g(m<span class="number">-1</span>))(self(self))(n)</div><div class="line"><span class="built_in">console</span>.log(fact4(fact4)(<span class="number">5</span>))</div><div class="line"></div><div class="line"><span class="comment">// 很明显fact4中的(g) =&gt; (m) =&gt; m&lt;=1?1:m*g(m-1) 就是 fact_gen</span></div><div class="line"><span class="comment">// 这就很有意思啦，这个fact_gen上下文无关了, 可以作为参数传入了</span></div><div class="line"><span class="keyword">const</span> weirdFunc = <span class="function">(<span class="params">func_gen</span>) =&gt;</span> (self) =&gt; <span class="function">(<span class="params">n</span>) =&gt;</span> func_gen(self(self))(n)</div><div class="line"><span class="built_in">console</span>.log(weirdFunc(fact_gen)(weirdFunc(fact_gen))(<span class="number">5</span>)) <span class="comment">//120</span></div><div class="line"></div><div class="line"><span class="comment">// 此时我们就得到了一种Y组合子的形式了</span></div><div class="line"><span class="keyword">const</span> Y_ = <span class="function">(<span class="params">gen</span>) =&gt;</span> (f) =&gt; <span class="function">(<span class="params">n</span>)=&gt;</span> gen(f(f))(n)</div><div class="line"></div><div class="line"><span class="comment">// 构造一个阶乘递归也很easy了</span></div><div class="line"><span class="keyword">const</span> factorial = Y_(fact_gen)</div><div class="line"><span class="built_in">console</span>.log(factorial(factorial)(<span class="number">5</span>)) <span class="comment">//120</span></div><div class="line"></div><div class="line"><span class="comment">// 但上面这个factorial并不是我们想要的</span></div><div class="line"><span class="comment">// 只是一种fact2,fact3,fact4的形式</span></div><div class="line"><span class="comment">// 我们肯定希望这个函数的调用是factorial(5)</span></div><div class="line"><span class="comment">// 没问题，我们只需要把定义一个 f' = f(f) = (f)=&gt;f(f)</span></div><div class="line"><span class="comment">// eg. const factorial = fact2(fact2)</span></div><div class="line"><span class="keyword">const</span> Y = <span class="function"><span class="params">gen</span> =&gt;</span> n =&gt; (<span class="function"><span class="params">f</span>=&gt;</span>f(f))(gen)(n)</div><div class="line"><span class="built_in">console</span>.log(Y(fact2)(<span class="number">5</span>)) <span class="comment">//120</span></div><div class="line"><span class="built_in">console</span>.log(Y(fact3)(<span class="number">5</span>)) <span class="comment">//120</span></div><div class="line"><span class="built_in">console</span>.log(Y(fact4)(<span class="number">5</span>)) <span class="comment">//120</span></div></pre></td></tr></table></figure>
<p>推导到这里，是不是已经感觉到脊背嗖凉了一下，反正笔者我第一次接触在<a href="http://mindhacks.cn/2006/10/15/cantor-godel-turing-an-eternal-golden-diagonal/" target="_blank" rel="external">康托尔、哥德尔、图灵——永恒的金色对角线</a>这篇文章里接触到的时候，整个人瞬间被这种以数学语言去表示程序的方式所折服。</p>
<p>来，我们回忆下，我们最终是不是得到了一个不定点算子，这个算子可以找出一个高阶函数的不动点<code>f(Y(f)) = Y(f)</code>。 将一个函数传入一个算子(函数)，得到一个跟自己功能一样，但又并不是自己的函数，这个说法有些拗口，但又味道十足。</p>
<p>好了，我们回到最初的问题，怎么完成匿名函数的递归呢？有了Y组合子就很简单了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*求不动点*/</span></div><div class="line">(<span class="function"><span class="params">f</span> =&gt;</span> f(f))</div><div class="line"><span class="comment">/*以不动点为参数的递归函数*/</span></div><div class="line">(<span class="function"><span class="params">fact</span> =&gt;</span> n =&gt; n &lt;= <span class="number">1</span> ? <span class="number">1</span> : n * fact(fact)(n - <span class="number">1</span>)) </div><div class="line"><span class="comment">/*递归函数参数*/</span> </div><div class="line">(<span class="number">5</span>)</div><div class="line"><span class="comment">// 120</span></div></pre></td></tr></table></figure>
<p>曾经看到过一些说法是”最让人沮丧是，当你推导出它(Y组合子)后，完全没法儿通过只看它一眼就说出它到底是想干嘛”，而我恰恰认为这就是函数式编程的魅力，也是数学的魅力所在，精简优雅的公式，背后隐藏着复杂有趣的推导过程。<br><img src="http://cdn.codedocker.com/2016-09-19-14742702215275.jpg" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>务实点儿讲，匿名函数的递归调用，在日常的js开发中，用到的真的很少。把这个问题拿出来讲，主要是想引出对<code>arguments</code>的一些讲解和对<code>Y组合子</code>这个概念的一个普及。</p>
<p>但既然讲都讲了，我们真的用到的话，该怎么选择呢？来，我们喜闻乐见的benchmark下：<br>分别测试：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// fact </span></div><div class="line">fact(<span class="number">10</span>)</div><div class="line"><span class="comment">// Y</span></div><div class="line">(<span class="function"><span class="params">f</span> =&gt;</span> f(f))(<span class="function"><span class="params">fact</span> =&gt;</span> n =&gt; n &lt;= <span class="number">1</span> ? <span class="number">1</span> : n * fact(fact)(n - <span class="number">1</span>))(<span class="number">10</span>)</div><div class="line"><span class="comment">// Y'</span></div><div class="line"><span class="keyword">const</span> fix = <span class="function">(<span class="params">f</span>) =&gt;</span> f(f)</div><div class="line"><span class="keyword">const</span> ygen = fix(fact2)</div><div class="line">ygen(<span class="number">10</span>)</div><div class="line"><span class="comment">// callee</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;n&lt;=<span class="number">1</span>?<span class="number">1</span>:n*<span class="built_in">arguments</span>.callee(n<span class="number">-1</span>)&#125;)(<span class="number">10</span>)</div></pre></td></tr></table></figure>
<p>环境：Macbook pro(2.5 GHz Intel Core i7), node-5.0.0(V8:4.6.85.28)<br>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fact x 18,604,101 ops/sec ±2.22% (88 runs sampled)</div><div class="line">Y x 2,799,791 ops/sec ±1.03% (87 runs sampled)</div><div class="line">Y&apos; x 3,678,654 ops/sec ±1.57% (77 runs sampled)</div><div class="line">callee x 2,632,864 ops/sec ±0.99% (81 runs sampled)</div></pre></td></tr></table></figure>
<p>可见Y和callee的性能相差不多，因为需要临时构建函数，所以跟直接的fact递归调用有差不多一个数量级的差异,将不定点函数算出后保存下来，大概会有一倍左右的性能提升。</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ol>
<li><a href="http://mindhacks.cn/2006/10/15/cantor-godel-turing-an-eternal-golden-diagonal/" target="_blank" rel="external">康托尔、哥德尔、图灵——永恒的金色对角线</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="external">箭头函数</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E4%B8%8D%E5%8A%A8%E7%82%B9%E7%BB%84%E5%90%88%E5%AD%90" target="_blank" rel="external">不动点组合子</a></li>
</ol>
<span id="return-to-top"></span><div data-thread-key="2016/10/10/recur/" data-title="Javascript中匿名函数的递归调用" data-url="http://fe.dianwoda.com/2016/10/10/recur/" data-images='["http://cdn.codedocker.com/2016-09-19-14742702215275.jpg"]' class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-32"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more"></a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo"></a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat"></a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2016/10/10/recur/" data-title="Javascript中匿名函数的递归调用" data-url="http://fe.dianwoda.com/2016/10/10/recur/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"dwd-fe"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></div></article><nav id="post-pagination"><a href="/2016/10/10/hello-world/" class="next"></a></nav></div></div><div class="copyright"><small>点我达FE 版权所有 ©️点我达FE all rights reserved. powered by <a href="https://hexo.io/" target="_blank">Hexo</a>.</small></div></div><script src="/js/Dwd-Fe.js"></script></body></html>