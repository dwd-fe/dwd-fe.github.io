<!DOCTYPE html><html lang="zh-cmn-Hans"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title> JavaScript的原型和原型链的前世今生(一) · 点我达前端博客</title><meta name="description" content="JavaScript的原型和原型链的前世今生(一) - 点我达team"><link rel="stylesheet" href="/css/Dwd-Fe.css"><link rel="short icon" href="/favicon.ico"></head><body><div class="wrapper"><header id="menu-outer"><a href="/"><div class="logo"><img src="http://7xtb3a.com2.z0.glb.clouddn.com/icon@2x.png"></div></a><nav id="menu-inner"><a href="/">首页</a><a href="/archives">分类</a><a href="/about">关于我们</a><a href="https://github.com/dwd-fe">Github</a></nav></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="post-space"><div class="post-title"><h1>JavaScript的原型和原型链的前世今生(一)</h1><h2>by 林小兀 on 2016-11-01</h2><h2><span>分类 </span><a class="tags-link" href="/tags/javascript/">javascript</a></h2></div></div><img src="http://blogimages2016.oss-cn-hangzhou.aliyuncs.com/javascript/constructor2.png" class="post-back"></div><div class="post-content"><p>大家不要被这个感觉高大上的名字给吓着，我没有打算把<code>原型</code>的历史给说一遍，本文只是想帮助大家理解为什么要有原型和原型链这个独一无二的语言特性，别的语言(或者说是我学过的编程语言中)没有见过这一个概念的，这也是我从C语言转来学习JavaScript的时候最为困惑不解的地方。</p>
<h2 id="1、先从JavaScript创建对象说起"><a href="#1、先从JavaScript创建对象说起" class="headerlink" title="1、先从JavaScript创建对象说起"></a>1、先从JavaScript创建对象说起</h2><p>大家都知道JavaScript是一门面向对象的语言，但是没有类的概念(除非现在的ES6标准)。个人觉得ES6是在ES5上再封装的一个新标准，本质的实现还是ES5，所以掌握了ES5才算是掌握了精髓。没有类的概念，但是肯定有对象的概念，而JS的对象就与其他面向对象的语言(比如C++)不一样了。每个对象都是基于一个<code>引用类型</code>(比如Array/Date/Function等都属于引用类型，具体参考《JavaScript高级程序设计(第三版)》的第五章)或者一个自定义的类型来实现。</p>
<p>以前最常见的创建对象方法是(通过创建一个Object实例)：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> animal = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">animal.name = <span class="string">'WangWang'</span>;</div><div class="line">animal.type = <span class="string">'dog'</span>;</div><div class="line"></div><div class="line">animal.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'I am a '</span> + <span class="keyword">this</span>.type);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之后出现了对象字面量的创建方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Animal= &#123;</div><div class="line">   <span class="attr">name</span>: <span class="string">'WangWang'</span>,</div><div class="line">   <span class="attr">type</span>: <span class="string">'dog'</span>,</div><div class="line">   <span class="attr">say</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'I am a '</span> + <span class="keyword">this</span>.type);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先清楚的是一个对象肯定包含属性和方法：name和type肯定属于属性，say肯定属于方法。其次属性在浏览器的内部有对应的特性，这些特性是内部JS引擎使用的。</p>
<h3 id="1-1、谈谈JS对象中的属性-Property"><a href="#1-1、谈谈JS对象中的属性-Property" class="headerlink" title="1.1、谈谈JS对象中的属性(Property)"></a>1.1、谈谈JS对象中的属性(<code>Property</code>)</h3><p>按照<a href="http://www.ecma-international.org/ecma-262/5.1/index.html" target="_blank" rel="external">ES5</a>标准，属性除了我们在印象中知道的一个名字，一个值，类似于键值对的形式，其实在浏览器内部是有一大篇文章在里面的。</p>
<p>属性分为数据属性(‘Data Property’)和访问器属性(<code>Accessor Property</code>)。刚才定义的name和type都是数据属性，区别数据属性和访问器数据的依据便是访问器属性有<code>[[Get]]</code>和<code>[[Set]]</code>方法并且它不包含<code>[[value]]</code>特性(<code>Attribute</code>)。</p>
<p>数据属性包含4个特性：<code>[[configurable]]</code>、<code>[[Enumerable]]</code>、<code>[[Writable]]</code>、<code>[[Value]]</code>。</p>
<p>访问器属性包含4个特性：<code>[[Configurable]]</code>、<code>[[Enumerable]]</code>、<code>[[Get]]</code>、<code>[[Set]]</code>。</p>
<p>尽管这些特性是浏览器内部使用，但是ES5仍然提供了接口供我们去调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Object.defineProperty(obj, prop, descriptor);</div><div class="line">Object.defineProperties(obj, props);</div><div class="line">Object.getOwnPropertyDescriptor(obj, prop);</div><div class="line">Object.getOwnPropertyDescriptors(obj);</div></pre></td></tr></table></figure>
<p>随便举个例子(在Chrome控制台中)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; Object.getOwnPropertyDescriptor(Person, &quot;name&quot;)</div><div class="line">&gt; Object &#123;value: &quot;WangWang&quot;, writable: true, enumerable: true, configurable: true&#125;</div></pre></td></tr></table></figure>
<p>这4个API更多细节(比如兼容性)可以参考：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="external">MDN</a></p>
<h2 id="2、创建JS对象的进阶"><a href="#2、创建JS对象的进阶" class="headerlink" title="2、创建JS对象的进阶"></a>2、创建JS对象的进阶</h2><p>虽然Object<code>构造函数</code>或对象字面量都可以用来创建单个对象，但是很明显都有一个明显的缺陷：这种将对象创建以及对象实例化糅合在一起的做法直接导致代码无法复用接着就会产生一大堆重复的代码，所以为了解决这个问题就产生了新的创建对象的方法–<code>工厂模式</code>。这种形式开始慢慢地向C++语言的类和对象实例化靠近，更加贴近实际的代码开发。</p>
<h3 id="2-1、工厂模式"><a href="#2-1、工厂模式" class="headerlink" title="2.1、工厂模式"></a>2.1、工厂模式</h3><p>很形象的称呼，一听到这个名字我们就知道届时有一个工厂，只要我们提供原料就可以使用工厂的模子帮我们创建出我们想要的对象(也就是实例化的过程)。</p>
<p>因为ES5中无法创建类，所以就只能用函数来封装以特定接口创建对象的细节。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function createAnimal(name, type)&#123;</div><div class="line">   var o = new Object();</div><div class="line">   o.name = name;</div><div class="line">   o.type = type;</div><div class="line">   o.say = function()&#123;</div><div class="line">       console.log(&apos;I am a &apos; + this.type);</div><div class="line">   &#125;</div><div class="line">   return o;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var dog = createAnimal(&apos;WangWang&apos;, &apos;dog&apos;);</div></pre></td></tr></table></figure>
<p>这种方式虽然解决了对象实例化代码重复度的问题，但却没有解决对象识别的问题(也就是说这种方式创建的对象无法知道它的类型，比如说之前的第二种方法创建的对象，可以知道其对象的类型是Person)。所以演变着又有另外一种方式来创建对象。</p>
<h3 id="2-2、构造函数模式"><a href="#2-2、构造函数模式" class="headerlink" title="2.2、构造函数模式"></a>2.2、构造函数模式</h3><p>构造函数在C++语言中是一个基本概念，其作用是在实例化一个对象之后会初始化调用，并执行某些复制操作，可以看做是一个初始化函数。同理，JS在这里使用的构造函数虽然形式和C++的不一样，但是本质是一样的。JS提供了一些原生的构造函数有：<code>Object/Array/String</code>等，也可以创建自定义的。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name, type</span>)</span>&#123;</div><div class="line">   <span class="keyword">this</span>.name = name;</div><div class="line">   <span class="keyword">this</span>.type = type;</div><div class="line">   <span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">       <span class="built_in">console</span>.log(<span class="string">'I am a '</span> + <span class="keyword">this</span>.type);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Animal(<span class="string">'WangWang'</span>, <span class="string">'dog'</span>);</div></pre></td></tr></table></figure>
<p>此构造函数有以下三个特征：</p>
<ul>
<li>没有显式地创建对象</li>
<li>直接将属性和方法赋给了this对象</li>
<li>没有return语句</li>
</ul>
<p>在执行new操作的时候会经历以下4个步骤：</p>
<ul>
<li>创建一个对象</li>
<li>将构造函数的作用域赋给新对象(因此this指针就指向了新的对象)</li>
<li>执行构造函数中的代码</li>
<li>返回新对象</li>
</ul>
<p>这个时候的dog是一个Animal实例，按照C++语言的传统，每个实例肯定都有一个叫做constructor的属性，JS也是一样的，JS中的实例的constructor属性指向了Animal这个构造函数。</p>
<p>前面三种方法创建的对象都是一样的，所以任取一个，就拿工厂模式来对比：</p>
<p><img src="http://blogimages2016.oss-cn-hangzhou.aliyuncs.com/javascript/constructor.png" alt=""></p>
<p>可以看出构造函数方法的确是多了一个属性的，至于为什么这些属性集中在<code>__proto__</code>下，正是我们后面要提及的。</p>
<p>所以我们可以通过constructor属性来标识对象的类型(比如本例中的Animal类型)，也就是使用<code>instanceof</code>来验证的。</p>
<p>当然使用构造函数并不是完美无缺，使用构造函数的主要问题就是每个方法都要在每个实例中创建一遍，也就是说当我们创建Animal对象的时候，里面的方法其实是Function对象的实例，也就是等同于：</p>
<p><code>this.say = new Function( console.log(&#39;I am a &#39; + this.type);)</code></p>
<p>这样就导致创建多个实例会实例很多个函数对象，这样明显会增加内存消耗，为了解决这个问题，我们便引入了原型模式。</p>
<h2 id="3、原型模式"><a href="#3、原型模式" class="headerlink" title="3、原型模式"></a>3、原型模式</h2><p>刚才的图1中我们已经发现每个对象无论是用什么方法创建的，都有一个<code>__proto__</code>属性，这个<code>__proto__</code>属性便是连接原型链的关键地方，在上一节中我们说到的执行new的操作时会执行4个步骤，其中第二个步骤如果按照代码来说便是执行赋值操作，也就是：<code>dog.__proto__ = Animal.prototype</code>，可以通过控制台打印看出来：</p>
<p><img src="http://blogimages2016.oss-cn-hangzhou.aliyuncs.com/javascript/constructor1.png" alt=""></p>
<p>原型模式创建的方法采用是诸如这样的形式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"></div><div class="line">Animal.prototype.name = <span class="string">'WangWang'</span>;</div><div class="line">Animal.prototype.type = <span class="string">'dog'</span>;</div><div class="line">Animal.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">       <span class="built_in">console</span>.log(<span class="string">'I am a '</span> + <span class="keyword">this</span>.type);</div><div class="line">   &#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Animal();</div></pre></td></tr></table></figure>
<p>原型模式和构造函数模式的区别可以通过下面这张图看出来：</p>
<p>构造函数模式：</p>
<p><img src="http://blogimages2016.oss-cn-hangzhou.aliyuncs.com/javascript/constructor2.png" alt=""></p>
<p>原型模式：</p>
<p><img src="http://blogimages2016.oss-cn-hangzhou.aliyuncs.com/javascript/constructor3.png" alt=""></p>
<p>从上面两张图片可以看出原型的优缺点，如何改进呢？将二者融合是不是可以充分利用二者的优点呢？你要是这么想，那说明你是对的^_^ ! 这个便是3.2小节要讲的内容。</p>
<p>除了原型使用上面的赋值操作，我们目前更喜欢使用对象字面量或者是new关键词来操作原型。但是使用对象字面量或者new关键词有一个很重要的知识点：<strong>无论是使用对象字面量还是new关键词，都是创建一个新的对象来替换掉原来的原型对象</strong>。</p>
<p>很是抽象？一张图来告诉你真相：</p>
<p>代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"></div><div class="line">Animal.prototype = &#123;</div><div class="line">     <span class="attr">name</span>: <span class="string">'WangWang'</span>,</div><div class="line">     <span class="attr">type</span>:  <span class="string">'dog'</span>,</div><div class="line">     <span class="attr">say</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">       <span class="built_in">console</span>.log(<span class="string">'I am a '</span> + <span class="keyword">this</span>.type);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Animal();</div></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Species</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.name =  <span class="string">'WangWang'</span>;</div><div class="line">  <span class="keyword">this</span>.type =  <span class="string">'dog'</span>;</div><div class="line">  <span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">       <span class="built_in">console</span>.log(<span class="string">'I am a '</span> + <span class="keyword">this</span>.type);</div><div class="line">   &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"></div><div class="line">Animal.prototype = <span class="keyword">new</span> Species();</div><div class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Animal();</div></pre></td></tr></table></figure>
<p>二者对应的原型模式图示：</p>
<p><img src="http://blogimages2016.oss-cn-hangzhou.aliyuncs.com/javascript/constructor4.png" alt=""></p>
<blockquote>
<p>所以正是因为这种overridden的效果，<em>当你使用这种方法的时候一定要注意原型对象是否还是原来的原型对象</em>。</p>
</blockquote>
<p>那二者都有优点，组合使用如何？原型链又与原型有什么关系？</p>
<p>请看下一篇：<a href="http://fe.dianwoda.com/2016/11/01/JavaScript的原型和原型链的前世今生(二)">JavaScript的原型和原型链的前世今生(二)</a></p>
<span id="return-to-top"></span><div data-thread-key="2016/11/01/JavaScript的原型和原型链的前世今生(一)/" data-title="JavaScript的原型和原型链的前世今生(一)" data-url="http://fe.dianwoda.com/2016/11/01/JavaScript的原型和原型链的前世今生(一)/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"dwd-fe"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></div></article><nav id="post-pagination"><a href="/2016/11/01/JavaScript的原型和原型链的前世今生(二)/" class="prev"></a><a href="/2016/11/01/前端从入门到再次入门 - 异步/" class="next"></a></nav></div></div><div class="copyright"><small>点我达FE 版权所有 ©️点我达FE all rights reserved. powered by <a href="https://hexo.io/" target="_blank">Hexo</a>.</small></div></div><script src="/js/Dwd-Fe.js"></script></body></html>