<!DOCTYPE html><html lang="zh-cmn-Hans"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title> 前端从入门到再次入门 - 异步 · 点我达前端博客</title><meta name="description" content="前端从入门到再次入门 - 异步 - 点我达team"><link rel="stylesheet" href="/css/Dwd-Fe.css"><link rel="short icon" href="/favicon.ico"></head><body><div class="wrapper"><header id="menu-outer"><a href="/"><div class="logo"><img src="http://7xtb3a.com2.z0.glb.clouddn.com/icon@2x.png"></div></a><nav id="menu-inner"><a href="/">首页</a><a href="/archives">分类</a><a href="/about">关于我们</a><a href="https://github.com/dwd-fe">Github</a></nav></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="post-space"><div class="post-title"><h1>前端从入门到再次入门 - 异步</h1><h2>by 黄凯羿 on 2016-11-01</h2><h2><span>分类 </span><a class="tags-link" href="/tags/javascript/">javascript</a></h2></div></div><img src="http://7xtb3a.com2.z0.glb.clouddn.com/restr.jpeg" class="post-back"></div><div class="post-content"><p>异步是什么？那要从 javascript 这门语言说起。</p>
<p>javascript 诞生于1995年，作为当时浏览器专属的脚本语言，它被设计成了单线程。也就是说它在同一时间内只能做一件事。为什么是这样的呢？想象一下当 javascript 为多线程时，用户在一个节点添加内容，又在一个线程删除这个节点，浏览器该怎么去响应呢？</p>
<p>javascript 用单线程解决了浏览器里复杂的同步问题，但是单线程的话必然得引入一个概念，就是任务队列。在一个文明的社会里，需求多而物品少的话必然得排队，程序也是如此。当一个任务结束，下一个任务才会开始，看起来这样的规则很完美，但是有缺陷么？有的。比如说你去你最爱的面馆吃饭，结果发现门口排着长长的队，里面的座位却都是空的。原来这家面馆的流程是：顾客点单，小二下单 —— 顾客和小二大眼瞪小眼 —— 厨房把菜给小二，小二给顾客 —— 顾客端着菜来到餐桌吃饭 —— 结束。</p>
<p>这样的一个流程最要命的地方就在于顾客和小二大眼瞪小眼的阶段，时间都浪费在了这上面，所以排了很长的队大家都不满意。该怎么优化呢？</p>
<p>和面馆老板讨论后，给出了这样的优化方案：</p>
<p>顾客点单，小二下单 —— 小二给一个牌子给顾客，代表顾客的编号 —— 顾客坐在餐桌上开始玩手机聊天 —— 厨房把菜给小二，小二根据编号给顾客 —— 结束。</p>
<p>老板一听这样好呀，排队点人少了，小二的效率也高了，于是就请我吃了他们最好吃的牛肉面。</p>
<p>这就是异步，把耗时的操作在别的地方执行，执行完再把结果放回队列中。这样在这之间的时间可以做别的操作，而不是阻塞在这里。话说回来，javascript 语言是怎么实现异步的呢？就是回调函数。</p>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>回调函数的英文名叫 callback，简单来说就是执行完一个任务后调用这个回调函数，这个回调函数能得到这个任务的结果。在 javascript 世界里到处都有回调函数的身影。最简单的就是 setTimeout 方法了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> alert(<span class="string">'1000毫秒后出现我！'</span>), <span class="number">1000</span>)</div></pre></td></tr></table></figure>
<p>上面的代码实际上的任务是等待1000毫秒，<code>() =&gt; alert(&#39;1000毫秒后出现我！&#39;)</code>就是回调函数。</p>
<p>回调函数很好用也很好理解，但是需要多个异步数据一起利用怎么办？一个异步任务的必要条件是另一个异步任务的结果又该怎么办？有人就开始写嵌套的 callback，俗称回调金字塔。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">fun1(<span class="function"><span class="keyword">function</span> (<span class="params">value1</span>) </span>&#123;</div><div class="line">    fun2(value1, <span class="function"><span class="keyword">function</span>(<span class="params">value2</span>) </span>&#123;</div><div class="line">        fun3(value2, <span class="function"><span class="keyword">function</span>(<span class="params">value3</span>) </span>&#123;</div><div class="line">            fun4(value3, <span class="function"><span class="keyword">function</span>(<span class="params">value4</span>) </span>&#123;</div><div class="line">                <span class="comment">// …</span></div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这种代码在 node 等高频异步处理里很常见。写着是挺好写的，等过了一天后你回头看自己的代码，写得都是写什么鬼？</p>
<p>至此我们就要踏上一场寻找前端异步处理最佳方案的道路。正如题目所说，你以为你入门了，其实前方还有一道又一道的门，俗称前端摩尔定律～</p>
<h2 id="EventProxy-与发布／订阅模式"><a href="#EventProxy-与发布／订阅模式" class="headerlink" title="EventProxy 与发布／订阅模式"></a>EventProxy 与发布／订阅模式</h2><p>正如这个库的作者<a href="https://github.com/JacksonTian" target="_blank" rel="external">朴灵</a>大大所说：</p>
<blockquote>
<p>这个世界上不存在所谓回调函数深度嵌套的问题。 —— <a href="http://weibo.com/shyvo" target="_blank" rel="external">Jackson Tian</a></p>
<p>世界上本没有嵌套回调，写得人多了，也便有了<code>}}}}}}}}}}}}</code>。 —— <a href="http://fengmk2.github.com" target="_blank" rel="external">fengmk2</a></p>
</blockquote>
<p><a href="https://github.com/JacksonTian/eventproxy" target="_blank" rel="external">EventProxy</a>就是为了解决嵌套的。</p>
<p>如果你要并发异步获取几个个地址的数据，并在获取所有数据后对这些数据进行处理的话，除了回调金字塔外最简单的写法是自己写一个计数器。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</div><div class="line"><span class="keyword">var</span> result = &#123;&#125;;</div><div class="line"></div><div class="line">$.get(<span class="string">'http://demo1'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">	result.data1 = data;</div><div class="line">	count++;</div><div class="line">	handle();</div><div class="line">&#125;);</div><div class="line">$.get(<span class="string">'http://demo2'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">	result.data2 = data;</div><div class="line">	count++;</div><div class="line">	handle();</div><div class="line">&#125;);</div><div class="line">$.get(<span class="string">'http://demo3'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">	result.data3 = data;</div><div class="line">	count++;</div><div class="line">	handle();</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">if</span> (count === <span class="number">3</span>) &#123;</div><div class="line">	  <span class="comment">// 后续操作result</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用了 EventProxy 以后：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> eventproxy();</div><div class="line"></div><div class="line">proxy.all(<span class="string">'data1_event'</span>, <span class="string">'data2_event'</span>, <span class="string">'data3_event'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data1, data2, data3</span>) </span>&#123;</div><div class="line">  <span class="comment">// 后续操作result</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">$.get(<span class="string">'http://demo1'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">  proxy.emit(<span class="string">'data1_event'</span>, data);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">$.get(<span class="string">'http://demo2'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">  proxy.emit(<span class="string">'data2_event'</span>, data);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">$.get(<span class="string">'http://demo3'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">  proxy.emit(<span class="string">'data3_event'</span>, data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这是一个典型的事件发布／订阅模式。我们抛开代码，先来聊聊什么是发布／订阅模式。</p>
<p>发布／订阅模式，又叫做观察者模式。发布／订阅模式定义了一种一对多的依赖关系，让多个订阅者对象同时监听某一个主题对象。这个主题对象在自身状态变化时，会通知所有订阅者对象，使它们能够自动更新自己的状态。</p>
<p>简单的说，你最爱的面馆的厨师回乡娶媳妇去了，新厨师做的牛肉面不合你口味，于是你每天都打电话给餐馆问老厨师回来了么。老板再也受不了了，每天都接到类似的电话要疯了，问我怎么处理。我说简单啊，把每个想吃老厨师做牛肉面的人的电话记下来，和他们说老厨师来了就给他们发短信。于是老板的电话终于安静了。</p>
<p>上面这个弱智的例子就是发布／订阅模式，我们生活中经常会遇到。老板是发布者，顾客是订阅者，顾客订阅了老厨师回来的信息，当老厨师回来后老板把这个消息发布给顾客。发布／订阅模式有什么好处呢？它能够解耦逻辑，发布者不用关心订阅者具体的业务逻辑，也不用关心有多少订阅者，就能把消息传递给订阅者。订阅者也不用每次询问发布者有没有消息，但也会在第一时间得到他想要的消息。</p>
<p>回到 EventProxy，上面例子中<code>proxy.emit(&#39;data1_event&#39;, data)</code>就是发布者，<code>proxy.all</code>就是订阅者，但是 EventProxy 的 all API 可以同时订阅多个消息，并在获得所有消息后进行处理，这是对普通发布／订阅模式的扩充。</p>
<p>EventProxy 具体的实现原理来自 Backbone 的事件模块，感兴趣的可以去它的<a href="https://github.com/JacksonTian/eventproxy" target="_blank" rel="external">github</a>里查看。</p>
<h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><p>promise 是什么？promise 的中文意思是承诺。</p>
<p>记得我第一次接触 promise 是在我第一个 angular 项目中，当时项目的代码里很多<code>promise.then().then()</code>，并不知道是什么意思，觉得好高端啊。当时的 leader 和我说，promise 很简单，就是先给你一个承诺，完成以后再进行下一步处理。它传递的始终是一个 promise 对象。</p>
<p>那时候我天真的以为 promise 只有 angular 才有，后来才发现 angular 里的 $q 只是其中一种 promise 实现。AngularJS 的整个代码库很大程度上依赖于 Promise，包括框架以及你用它编写的应用代码。</p>
<p>说回正题。有很多第三方库实现了 promise，像 when，angular 用的 $q 等。他们遵循同一规范：<a href="https://promisesaplus.com/" target="_blank" rel="external">Promises/A+</a>。如今在 ECMAScript 2015 规范中 javascript 支持了原生的 promise（当然如果想要兼容性的话请用 babel）。</p>
<p>所谓 Promise，就是有一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。一个 promise 可能有三种状态：未完成、已完成、已失败。一个 promise 的状态只可能从未完成转到已完成或者已失败，不能逆向转换，同时已完成和已失败不能相互转换。同时需要注意的是他们之间传递的都是 promise 对象。</p>
<p>举个栗子：你在面馆点了餐，小二给了你一个餐牌。这个餐牌对你来说没有什么用，你既不能吃又不能卖了换钱，只是代表你付了钱点了餐，这就是一个未完成的状态。厨房做好以后小二拿着牛肉面换你的餐牌，你得到了你想吃的牛肉面，这就是已完成的状态。厨房的牛肉卖完了，小二跑来和你道歉，让你换一碗面或者退你钱，这就是已失败状态和失败后的处理。已失败并不能直接转换成已完成，你想换一碗面还是要走一遍 promise 流程，这就是已完成和已失败不能相互转换。</p>
<p>知道了 promise 的理论后，我们来看看原生的 promise:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">    <span class="comment">// 小二承诺给你一碗牛肉面</span></div><div class="line">    <span class="keyword">if</span> (success)&#123;</div><div class="line">	    <span class="comment">// resolve牛肉面给你</span></div><div class="line">      <span class="keyword">return</span> resolve(data);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">	    <span class="comment">// 厨房牛肉卖完了，reject了一个错误给你</span></div><div class="line">      <span class="keyword">return</span> reject(data);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">    <span class="comment">// 成功啦，开吃</span></div><div class="line">    <span class="built_in">console</span>.log(data);</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">    <span class="comment">// 失败啦，我要退钱！！</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>这里的变量 promise 是 Promise 这个对象的实例。逻辑处理完以后如果没有错误，你就能在 then 中的第一个回调函数得到牛肉面，如果有错误则会在 then 中第二个回调函数中进行错误处理。</p>
<p>promise 还提供一个<code>Promise.all()</code>的方法，效果类似于 EventProxy 的 all，不过它返回的是一个 promise 对象。当所有 promise 对象都成功以后才会进入已完成状态，要是有其中一个 promise 进入已失败状态，<code>Promise.all</code>也会进入已失败状态。具体可以查看<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all</a></p>
<p>promise 最大的好处就是通过链式调用解决了回调的深层嵌套的问题，看起来很优雅，也很容易理解和使用。但你以为这就是 javascript 异步编程的全部了？</p>
<h2 id="Generator与TJ的co"><a href="#Generator与TJ的co" class="headerlink" title="Generator与TJ的co"></a>Generator与TJ的co</h2><p>Generator 中文含义是生成器。在 javascript 世界里，函数是不存在被执行之后还能暂停的情况，只有“被调用”和“没有被调用”的状态。当函数能够暂停的话会发生什么？</p>
<p>Generator就是那个能够暂停的函数，它的本质可以理解为一种特殊的数据结构。和普通函数相比，它多了一个<code>*</code>号，<code>*</code>号出现在关键字 function 和函数名之间，如果是匿名函数，则出现在 function 和参数列表的起始括号之间。</p>
<p>那么它是如何实现暂停的呢？通过函数里的 yield 关键字和 next 方法。我们先看一个例子简单的了解一下写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params">a, b</span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> sum = a + b;</div><div class="line">	<span class="keyword">yield</span> sum;</div><div class="line">	<span class="keyword">var</span> subtract = a - b;</div><div class="line">	<span class="keyword">yield</span> subtract;</div><div class="line">	<span class="keyword">return</span> a</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> generator = g(<span class="number">2</span>, <span class="number">1</span>);</div><div class="line"><span class="built_in">console</span>.log(generator.next()); <span class="comment">// &#123; value: 3, done: false &#125;</span></div><div class="line"><span class="built_in">console</span>.log(generator.next()); <span class="comment">// &#123; value: 1, done: false &#125;</span></div><div class="line"><span class="built_in">console</span>.log(generator.next()); <span class="comment">// &#123; value: 1, done: true &#125;</span></div></pre></td></tr></table></figure>
<p>我们一步一步的来解读下上面的例子：</p>
<p>1.首先创建了一个 Generator 函数，命名为 g。</p>
<p>2.实例化这个函数，命名为 generator。这时的 generator 是一个 Generator 对象，他有一个 next 方法。当你没有调用 next 的时候，Generator 函数内部执行到第一个 yield 前就暂停到这里不再执行了。</p>
<p>3.当我们第一次调用<code>generator.next()</code>时，会返回第一个 yield 后面的对象，不过返回的对象有两个属性，一个是 value，即它的本体；一个是 done，代表该 Generator 函数是否结束。所以第一次调用 next 返回了<code>{ value: 3, done: false }</code>。（注意：如果 yield 后面接的不是对象例如是字符串的话，next 会直接返回字符串）。</p>
<p>4.第二次调用如上，第三次调用的时候 Generator 函数已经没有 yield 关键字了，所以返回的 done 为 true。</p>
<p>需要注意的是，<code>.next()</code>调用只会执行 yield 后面的对象，下一次调用时才会执行完yield 所在行。我们可以通过<code>generator.next()</code>赋值来传递参数给函数。看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params">a, b</span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> sum = <span class="keyword">yield</span> a + b;</div><div class="line">	<span class="built_in">console</span>.log(sum);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> generator = g(<span class="number">2</span>, <span class="number">1</span>);</div><div class="line">generator.next();</div><div class="line">generator.next(<span class="string">"hello"</span>); <span class="comment">// hello</span></div></pre></td></tr></table></figure>
<p>这个例子和前面的很像，只是我们把 yield 加在了变量 sum 后面。当第一次执行<code>generator.next()</code>时，<code>generator.next()</code>和前面的例子一样返回<code>{ value: 3, done: false }</code>。这时还没有执行 sum 的赋值操作。再一次执行<code>generator.next(&quot;hello&quot;)</code>后，<code>generator.next(&quot;hello”)</code>返回<code>{ value: undefined, done: true }</code>，因为后面没有 yield 了。和前面的例子不一样的是我们传了一个 hello 给函数，这时会进行 sum 的赋值，即<code>var sum = “hello”</code>。所以函数运行到<code>console.log(sum)</code>的时候 sum 就是<code>hello</code>了。</p>
<p>通过这种方式动态的传递数据，使得代码逻辑更灵活，同时才有能力达到我们的目的：异步优化。异步怎么用 Generator 呢？首先能想到的就是在异步处理后把得到的值通过<code>generator.next(data)</code>传递给函数体。下面我结合 promise 用 Generator 来实现异步：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">resolve</span>)</span>&#123;</div><div class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">"hello"</span>),<span class="number">1000</span>);</div><div class="line">&#125;); <span class="comment">// 创建一个 promise 模拟异步请求</span></div><div class="line"><span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> hello = <span class="keyword">yield</span> promise;</div><div class="line">    <span class="built_in">console</span>.log(hello);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> generator = g();</div><div class="line"><span class="keyword">var</span> result = generator.next();</div><div class="line">result.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">    generator.next(data);</div><div class="line">&#125;); <span class="comment">// 打印出"hello"</span></div></pre></td></tr></table></figure>
<p>这个例子我先创建了一个 promise 来模拟异步请求，然后在 Generator 函数体内 yield 了这个 promise。第一次执行<code>generator.next()</code>会返回一个 value 为 promise 对象，所以我们用 promise 的 then 里能得到异步返回的值，即例子里的”hello”。然后在 then 方法里再调用<code>generator.next(data)</code>把异步的返回值返回给 Generator 函数体。最后会打印出<code>hello</code>，结束这次异步处理。</p>
<p>虽然现在的异步有点像同步了，但是大家有没有觉得例子后面手动调用 generator.next() 很繁琐很丑么？不是很丑是丑屎了～</p>
<p>能不能装逼的方式简单一点呢？能。下面我要介绍一下著名程序员TJ大神写的co库。co库是一个基于 Generator 的函数库，主要目的是自动化调用<code>.next()</code>方法。具体的写法是在 co 函数里包裹一个 Generator 函数。</p>
<p>最早在 co 的 Generator 函数内只能 yield 一个 trunk 函数，1.1.0以后加入了 promise 支持，后续慢慢开始支持 generators, generator functions, object, array。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</div><div class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>)</span>&#123;</div><div class="line">	setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">"hello"</span>),<span class="number">1000</span>);</div><div class="line">&#125;);</div><div class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> hello = <span class="keyword">yield</span> promise</div><div class="line">	<span class="built_in">console</span>.log(hello)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>省去了手动调用<code>.next()</code>方法，写法更清晰了，就这么简单～</p>
<p>因为4.0.0版本以后 co 函数返回一个 promise 对象，你可以添加回调：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</div><div class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>)</span>&#123;</div><div class="line">	setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">"hello"</span>),<span class="number">1000</span>);</div><div class="line">&#125;);</div><div class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> hello = <span class="keyword">yield</span> promise</div><div class="line">	<span class="built_in">console</span>.log(hello)</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">"world!"</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>在早期版本（1.4.0）co 提供了一个<code>join</code>方法来实现并发异步，现在可以直接 yield 一个数组或者字符串来实现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// array</span></div><div class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> res = <span class="keyword">yield</span> [</div><div class="line">    <span class="built_in">Promise</span>.resolve(<span class="number">1</span>),</div><div class="line">    <span class="built_in">Promise</span>.resolve(<span class="number">2</span>),</div><div class="line">    <span class="built_in">Promise</span>.resolve(<span class="number">3</span>),</div><div class="line">  ];</div><div class="line">  <span class="built_in">console</span>.log(res); <span class="comment">// =&gt; [1, 2, 3]</span></div><div class="line">&#125;).catch(onerror);</div><div class="line"></div><div class="line"><span class="comment">// object</span></div><div class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> res = <span class="keyword">yield</span> &#123;</div><div class="line">    <span class="number">1</span>: <span class="built_in">Promise</span>.resolve(<span class="number">1</span>),</div><div class="line">    <span class="number">2</span>: <span class="built_in">Promise</span>.resolve(<span class="number">2</span>),</div><div class="line">  &#125;;</div><div class="line">  <span class="built_in">console</span>.log(res); <span class="comment">// =&gt; &#123; 1: 1, 2: 2 &#125;</span></div><div class="line">&#125;).catch(onerror);</div></pre></td></tr></table></figure>
<p>co 还允许你在函数体里用<code>try/catch</code>，这样很方便的抛出错误。co 的源码很少，感兴趣的童鞋可以去看一看<a href="https://github.com/tj/co/blob/master/index.js" target="_blank" rel="external">https://github.com/tj/co/blob/master/index.js</a>。</p>
<p>需要注意的是，Generator 是属于 ES6 的方法。不过如今 node 都发布到7.0版本了，是能够直接支持的。前端请用 babel。另外如果只是尝试一下的话可以打开 chrome 控制台。因为 chrome 是v8内核，可以直接使用 Generator 和 promise 的。</p>
<h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2><p>前面我们谈到了 co，这个好用的函数库有什么缺陷呢？首先它是一个第三方库，其次它只支持在 yield 后面接 promise 或者 trunk。这么好用的异步方案有没有官方的实现呢？恭喜你，在这个 javascript 极速进化的时代官方是有类似的方案的，这就是 async/await。</p>
<p>这个出现在 ES7 中的方案其实就是 Generator 的语法糖。我们看一下下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</div><div class="line">	setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">"hello"</span>),<span class="number">1000</span>);</div><div class="line">&#125;);</div><div class="line"><span class="keyword">const</span> testAsync = <span class="keyword">async</span> () =&gt; &#123;</div><div class="line">  <span class="keyword">const</span> hello = <span class="keyword">await</span> promise;</div><div class="line">  <span class="built_in">console</span>.log(hello);</div><div class="line">&#125;;</div><div class="line">testAsync();</div></pre></td></tr></table></figure>
<p>是不是和 co 一毛一样！唯一的区别就是把<code>*</code>换成了<code>async</code>，把 yield 换成了<code>await</code>，另外能像 co 一样执行类似 Generator 的<code>.next()</code>方法，也不用包裹在co函数里了。是不是很棒！</p>
<p>如果我们希望多个异步并发执行，类似于在 EventProxy 里那样，可以结合<code>Promise.all</code>来实现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</div><div class="line">	setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">"hello"</span>),<span class="number">1000</span>);</div><div class="line">&#125;);</div><div class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</div><div class="line">	setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">"world!"</span>),<span class="number">1000</span>);</div><div class="line">&#125;);</div><div class="line"><span class="keyword">const</span> testAsync = <span class="keyword">async</span> () =&gt; &#123;</div><div class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([promise1,promise2]);</div><div class="line">  <span class="built_in">console</span>.log(data);</div><div class="line">&#125;;</div><div class="line">testAsync();</div></pre></td></tr></table></figure>
<p>相比于 Generator，async/await 在语义上更清晰，<code>async</code>的意思是异步，<code>await</code>的意思是等待。async/await 本身就是为处理异步而生，而 Generator 并不是专门处理异步的。<code>await</code>后面除了可以跟 promise 对象，还可以用原始类型的值（当然这样的话就和同步操作没有区别了）。</p>
<p>这么酷的语法要使用的话在 node 端7.0版本已经原生支持，在前端可以通过 babel 编译来实现。当然万能的 chrome 控制台也可以直接使用的～</p>
<h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>在宁 js 大会上我第一次听说 Rx.js（原谅我孤陋寡闻），这也是很好的异步处理方案。等以后再专门写一篇 Rx.js 的入门。前端的异步解决方案这么多，说到底还是因为人们对于 callback 的恐惧。这些解决方案有个共同的特点，就是越来越像同步的代码，这样的好处就是代码更易读了，思维不用随着 callback 跳来跳去了。最后说一句，本文只是入门，没有涉及具体的实现，要想学好它们的话还是需要深入代码，了解它们背后的思想。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/alsotang/node-lessons/tree/master/lesson4" target="_blank" rel="external">https://github.com/alsotang/node-lessons/tree/master/lesson4</a><br><a href="http://www.infoq.com/cn/articles/generator-and-asynchronous-programming" target="_blank" rel="external">http://www.infoq.com/cn/articles/generator-and-asynchronous-programming</a></p>
<span id="return-to-top"></span><div data-thread-key="2016/11/01/前端从入门到再次入门 - 异步/" data-title="前端从入门到再次入门 - 异步" data-url="http://fe.dianwoda.com/2016/11/01/前端从入门到再次入门 - 异步/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"dwd-fe"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></div></article><nav id="post-pagination"><a href="/2016/10/26/前端渲染加速之 - Big Pipe/" class="next"></a></nav></div></div><div class="copyright"><small>点我达FE 版权所有 ©️点我达FE all rights reserved. powered by <a href="https://hexo.io/" target="_blank">Hexo</a>.</small></div></div><script src="/js/Dwd-Fe.js"></script></body></html>