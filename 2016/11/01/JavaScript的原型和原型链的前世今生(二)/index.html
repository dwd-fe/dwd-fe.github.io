<!DOCTYPE html><html lang="zh-cmn-Hans"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title> JavaScript的原型和原型链的前世今生(二) · 点我达前端博客</title><meta name="description" content="JavaScript的原型和原型链的前世今生(二) - 点我达team"><link rel="stylesheet" href="/css/Dwd-Fe.css"><link rel="short icon" href="/favicon.ico"></head><body><div class="wrapper"><header id="menu-outer"><a href="/"><div class="logo"><img src="http://7xtb3a.com2.z0.glb.clouddn.com/icon@2x.png"></div></a><nav id="menu-inner"><a href="/">首页</a><a href="/archives">分类</a><a href="/about">关于我们</a><a href="https://github.com/dwd-fe">Github</a></nav></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="post-space"><div class="post-title"><h1>JavaScript的原型和原型链的前世今生(二)</h1><h2>by 林小兀 on 2016-11-01</h2><h2><span>分类 </span><a class="tags-link" href="/tags/javascript/">javascript</a></h2></div></div><img src="http://blogimages2016.oss-cn-hangzhou.aliyuncs.com/javascript/constructor5.png" class="post-back"></div><div class="post-content"><h3 id="3-1、原型对象"><a href="#3-1、原型对象" class="headerlink" title="3.1、原型对象"></a>3.1、原型对象</h3><p>在上一篇文章中我们讲到的<code>prototype</code>属性，这个属性指向一个对象，而这个对象的用途是包含可以由<code>特定类型</code>的<code>所有实例</code>共享的属性和方法，在标准中我们称此对象为原型对象。原型对象会在创建一个新函数的时候根据一组特定的规则来生成。</p>
<p>既然有<code>prototype</code>这个属性，为什么上一篇文章中浏览器所截图的却都是<code>__proto__</code>？根据ECMA-262第五版中的介绍，实例内部的指针明确称为[[Prototype]]，虽然没有标准的方式访问该指针，但Firefox、Safari、Chrome在每个对象上都支持一个属性<code>__proto__</code>，所以你所见到的<code>__proto__</code>其实是浏览器自己实现的一个访问的接口，而不是标准设定的。但其实按照浏览器的设计来理解其实也更好的。</p>
<p>说了这么多，问个问题：<code>__proto__</code>是谁与谁的连接？自己可以好好琢磨哈。</p>
<blockquote>
<p>虽然无法访问到[[Prototype]]，但是可以使用isPrototypeof()方法来确定对象之间是否存在关系，也可以使用getPrototypeof()来获取[[Prototype]]的值。</p>
<p>既然原型对象的属性在实例化的对象中也可以访问到，那么有什么办法来判断访问的属性是在实例化的对象中还是在原型对象中呢？答案便是isOwnProperty()。</p>
<p>for-in循环将会遍历所有能够通过对象访问、可枚举的属性，无论该属性位于实例中还是原型中。在《JavaScript高级程序设计(第三版)》的6.2节有这么一段话，个人觉得有点多余：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">  屏蔽了原型中不可枚举属性(即将[[Enumerble]]标记为false的属性)的实例属性也会在for-in循环中返回。</div><div class="line">&gt;</div></pre></td></tr></table></figure>
<p>按照作者的理解是如果你在实例属性中定义了一个与原型中同样的名字的属性，并且在原型中该属性是不可枚举的，那么for-in依然会返回该属性。这个其实是很明显的命题，因为for-in在实例中找到该属性，并且该属性是可枚举的(除非你手动设置其为不可枚举)。</p>
<p>一个个枚举所有可枚举的属性比较麻烦，好在ES5提供了<code>Object.keys()</code>方法来获取所有可枚举的属性。如果想获取所有实例属性，可以使用<code>Object.getOwnPropertyNames()</code>。</p>
</blockquote>
<p>之前说过原型模式也是有缺点，其最大的缺点便是其共享的特性，随便修改原型对象中的任何一个属性，都会影响到它所实例化的所有对象，这样造成了不能出现“求同存异”的现象。因此我们会更多地使用下面的一种方法。</p>
<h3 id="3-2、组合使用构造函数模式和原型模式"><a href="#3-2、组合使用构造函数模式和原型模式" class="headerlink" title="3.2、组合使用构造函数模式和原型模式"></a>3.2、组合使用构造函数模式和原型模式</h3><p>组合使用当然是将所有共享的属性放在原型对象中，所有独特的属性放在构造函数中，这样的话可以实现真正的“求同存异”了。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function Animal()&#123;</div><div class="line">   this.name = name;</div><div class="line">   this.type = type;</div><div class="line">   this.say = function()&#123;</div><div class="line">       console.log(&apos;I am a &apos; + this.type);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Animal.prototype = &#123;</div><div class="line">   constructor: Animal;</div><div class="line">   feetCount: 0;</div><div class="line">   run: function()&#123;</div><div class="line">       console.log(&apos;I can run&apos;);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var dog = new Animal(&apos;WangWang&apos;, &apos;dog&apos;);</div></pre></td></tr></table></figure>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a><strong>注意：</strong></h3><blockquote>
<p>为什么这里的Animal.prototype要重新赋值constructor？</p>
<p>童鞋们结合上一篇文章可以思考一下！！</p>
</blockquote>
<p>那么我们是否可以考虑将上面的代码再优化一下，减少代码量？这时可以使用<code>动态原型模式</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function Animal()&#123;</div><div class="line">   this.name = name;</div><div class="line">   this.type = type;</div><div class="line">   this.say = function()&#123;</div><div class="line">       console.log(&apos;I am a &apos; + this.type);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   if (typeof this.run != &apos;function&apos;)&#123;</div><div class="line">      Animal.prototype.feetCount = 0;</div><div class="line">      Animal.prototype.run = function()&#123;</div><div class="line">         console.log(&apos;I can run&apos;);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var dog = new Animal(&apos;WangWang&apos;, &apos;dog&apos;);</div></pre></td></tr></table></figure>
<h3 id="注意：-1"><a href="#注意：-1" class="headerlink" title="注意："></a><strong>注意：</strong></h3><blockquote>
<p>为什么这里初始化原型的时候不能使用上面例子中的对象字面量的形式？</p>
<p>童鞋们也可以自己思考一下！！</p>
<p>在《JavaScript高级程序设计(第三版)》还介绍了两种模式来创建对象：<code>寄生(parasitic)构造函数模式</code>和<code>稳妥(Durable)构造函数模式</code>，细节可以参考书本。</p>
</blockquote>
<h2 id="4、原型链"><a href="#4、原型链" class="headerlink" title="4、原型链"></a>4、原型链</h2><p>想必讲到这里，你应该已经能够猜到原型链的实现原理了。ES5使用原型链来作为<code>实现继承</code>的主要方法(由于函数没有签名。在ES5中无法实现<code>接口继承</code>)。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。我们完善一下上一节的图片3：</p>
<p><img src="http://blogimages2016.oss-cn-hangzhou.aliyuncs.com/javascript/constructor5.png" alt=""></p>
<p>可以看出，通过<code>[[prototype]]</code>属性将实例、原型对象、原型对象的原型对象串联起来了，这个串联便是原型链。</p>
<p>同样原型链也是存在两个问题：</p>
<ul>
<li>原型中包含引用类型值的问题(也就是刚才3.1节说的问题)</li>
<li>在创建子类型实例时，不能向超类型的构造函数中传递参数</li>
</ul>
<p>因此常用的解决方案有下面几个：</p>
<h3 id="4-2、组合继承"><a href="#4-2、组合继承" class="headerlink" title="4.2、组合继承"></a>4.2、组合继承</h3><p><strong>组合继承</strong>(combination inheritance)有时候也叫作伪经典继承。该方案结合了借用构造函数(参考4.2.1小节)和原型链的。看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">function Species(name, type)&#123;</div><div class="line">   this.name = name;</div><div class="line">   this.type = type;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Species.prototype.run = function()&#123;</div><div class="line">    console.log(&apos;I can run ！&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function Animal(name, type, age)&#123;</div><div class="line">   Species.call(this, name, type);</div><div class="line"></div><div class="line">   this.age = 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Animal.prototype = new Species;</div><div class="line">Animal.prototype.constructor = Animal;</div><div class="line">Animal.prototype.reportAge = function()&#123;</div><div class="line">   console.log(&apos;my age is &apos; + this.age);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var dog = new Animal(&apos;WangWang&apos;, &apos;dog&apos;, 11);</div><div class="line">dog.run();</div><div class="line">dog.reportAge();</div></pre></td></tr></table></figure>
<p>该段代码的原型链图如下：</p>
<p><img src="http://blogimages2016.oss-cn-hangzhou.aliyuncs.com/javascript/constructor6.png" alt=""></p>
<h4 id="4-2-1、借用构造函数"><a href="#4-2-1、借用构造函数" class="headerlink" title="4.2.1、借用构造函数"></a>4.2.1、借用构造函数</h4><p><strong>借用构造函数(constructor stealing)</strong>(有时候也叫作伪造对象或经典继承)，实现原理很简单，那就是在子类型构造函数的内部调用超类型构造函数。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function Species()&#123;</div><div class="line">   this.colors= [&apos;red&apos;, &apos;green&apos;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">function Animal(type, name)&#123;</div><div class="line">   Species.call(this);</div><div class="line">   this.type = type;</div><div class="line">   this.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var dog = new Animal(&apos;dog&apos;, &apos;WangWang&apos;);</div><div class="line">dog.colors.push(&apos;black&apos;);</div><div class="line"></div><div class="line">var cat = new Animal(&apos;cat&apos;, &apos;MiMi&apos;);</div><div class="line">cat.colors.push(&apos;yellow&apos;);</div></pre></td></tr></table></figure>
<p>因为使用call函数的方法，让实例化Species超类的时候this指针指向了实例化的子类，相当于colors成了子类Animal的属性，因此每个实例操作的colors都是自己的私有属性。如下图：</p>
<p><img src="http://blogimages2016.oss-cn-hangzhou.aliyuncs.com/javascript/constructor7.png" alt=""></p>
<p>因为使用call方法，我们还可以传递参数给超类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function Species(feet)&#123;</div><div class="line">   this.colors= [&apos;red&apos;, &apos;green&apos;];</div><div class="line">   this.feet = feet</div><div class="line">&#125;</div><div class="line"></div><div class="line">function Animal(type, name, feet)&#123;</div><div class="line">   Species.call(this, feet);</div><div class="line">   this.type = type;</div><div class="line">   this.name = name;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方法导致的问题也就是构造函数的通病–那就是方法无法复用，每个实例都有自己一个实例的方法，所以一般采用上面的方式来使用。</p>
<h3 id="4-3、其他方案"><a href="#4-3、其他方案" class="headerlink" title="4.3、其他方案"></a>4.3、其他方案</h3><p>除了组合继承，还有原型式继承、寄生式继承、寄生组合式继承等三种方法，后面的这三种方法用到的地方不多，所以不做介绍，细节可以参考《JavaScript高级程序设计(第三版)》。</p>
<h2 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h2><p>通过这篇文章，从最初最简单的对象创建到后面的构造函数模式、原型模式创建对象，可以看出这门语言的强大生机，在不断地优化中变得越来越有意思。我们从这些演变中也掌握了对象的创建方法，顺便学习了原型以及原型链那些比较晦涩的概念。深究一个概念往往便是深究其演变的历史，所以要知未来，历史不可忘也！！</p>
<h2 id="6、参考"><a href="#6、参考" class="headerlink" title="6、参考"></a>6、参考</h2><p>[1] 《JavaScript高级程序设计(第三版)》第6章</p>
<p>[2]  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference" target="_blank" rel="external">MDN</a></p>
<p>[3]  <a href="http://www.ecma-international.org/ecma-262/5.1/index.html" target="_blank" rel="external">ES5标准</a></p>
<span id="return-to-top"></span><div data-thread-key="2016/11/01/JavaScript的原型和原型链的前世今生(二)/" data-title="JavaScript的原型和原型链的前世今生(二)" data-url="http://fe.dianwoda.com/2016/11/01/JavaScript的原型和原型链的前世今生(二)/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"dwd-fe"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></div></article><nav id="post-pagination"><a href="/2016/11/01/Web优化训练营, 网页提速50倍/" class="prev"></a><a href="/2016/11/01/JavaScript的原型和原型链的前世今生(一)/" class="next"></a></nav></div></div><div class="copyright"><small>点我达FE 版权所有 ©️点我达FE all rights reserved. powered by <a href="https://hexo.io/" target="_blank">Hexo</a>.</small></div></div><script src="/js/Dwd-Fe.js"></script></body></html>